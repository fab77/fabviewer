"use strict";
/**
 * @author Fabrizio Giordano (Fab77)
 * @param in_radius - number
 * @param in_gl - GL context
 * @param in_position - array of double e.g. [0.0, 0.0, -7]
 */

import AbstractSkyEntity from './AbstractSkyEntity';
import SphericalGrid from './SphericalGrid';
import XYZSystem from './XYZSystem';
import global from '../Global';
import RayPickingUtils from '../utils/RayPickingUtils';
import {Vec3, Pointing} from 'healpixjs';
import {tileBufferSingleton} from './TileBuffer';
import {healpixGridTileDrawerSingleton} from './HealpixGridTileDrawer';
import {tileDrawerSingleton} from './TileDrawer';
import HiPSFormatSelectedEvent from '../events/HiPSFormatSelectedEvent';
import eventBus from '../events/EventBus';




class HiPS extends AbstractSkyEntity{

	static className = "HiPSEntity";
	
	constructor(in_radius, in_position, in_xRad, in_yRad, in_name, url, format, maxOrder){

		super(in_radius, in_position, in_xRad, in_yRad, in_name);

		this.radius = in_radius;
		this.gl = global.gl;
		this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA  );
		
		this.format = format == undefined ? "fits" : format;
		
		this.fitsReader = null;

		this.order = 0;

	    this.URL = url;
		this.maxOrder = maxOrder == undefined ? 7 : maxOrder;
		this.visibleTiles = {};

		this.showSphericalGrid = false;
		this.showXyzRefCoord = false;
		this.showEquatorialGrid = false;

		this.sphericalGrid = new SphericalGrid(1.004, this.gl);

		this.xyzRefSystem = new XYZSystem(this.gl);

		this.initShaders();
//		healpixGridTileDrawerSingleton.init();
//		tileDrawerSingleton.init();
		setInterval(()=> {this.updateVisibleTiles();}, 100);
		
		this.registerForEvents();
		
		this.minOrder = 3;
		this.prevOrder = this.minOrder;

		let nside = Math.pow(2, this.norder);
		this.healpix = new Healpix(nside);
		this.maxNPix = this.healpix.getNPix();
		
		this.fixedOrderFovLimit = 12.5;
		this.textures = [];
		this.textures.images = [];
		
		
//		this.addOrder0Tiles();
	}
	
	registerForEvents(){
		eventBus.registerForEvent(this, HiPSFormatSelectedEvent.name);
		eventBus.printEventBusStatus();
	}
	
	notify(in_event){
		if (in_event instanceof HiPSFormatSelectedEvent){
			if (in_event.hipsName == this.name && in_event.format.trim() !== this.format){
				this.clearAllTiles();
				this.format = in_event.format.trim();
				this.addOrder0Tiles();
				this.updateVisibleTiles();
			}
		}
	}

//	clearAllTiles(){
//		Object.keys(this.visibleTiles).forEach(tileKey => {
//			let tile = tileBufferSingleton.getTileByKey(tileKey);
//			tile.removeFromView();
//		});
//		this.removeOrder0Tiles();
//	}

//	show(){
//		this.addOrder0Tiles();
//	}


//	addOrder0Tiles(){
//		for(let i = 0; i < 12; i++){
//			tileBufferSingleton.getTile(0, i, this.format, this.URL).addToView();
//		}
//	}

//	removeOrder0Tiles(){
//		for(let i = 0; i < 12; i++){
//			tileBufferSingleton.getTile(0, i, this.format, this.URL).removeFromView();
//		}
//	}

	initShaders () {
		var _self = this;
		var fragmentShader = getShader("hips-shader-fs");
		var vertexShader = getShader("hips-shader-vs");

		this.gl.attachShader(this.shaderProgram, vertexShader);
		this.gl.attachShader(this.shaderProgram, fragmentShader);
		this.gl.linkProgram(this.shaderProgram);
		this.gl.program = this.shaderProgram;

		if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		this.gl.useProgram(this.shaderProgram);

		this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
		this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

		this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
		this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);

		this.setUniformLocation();


	    function getShader(id){
	    	var shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3) {
					str += k.textContent;
				}
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = _self.gl.createShader(_self.gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex") {
				shader = _self.gl.createShader(_self.gl.VERTEX_SHADER);
			} else {
				return null;
			}

			_self.gl.shaderSource(shader, str);
			_self.gl.compileShader(shader);

			if (!_self.gl.getShaderParameter(shader, _self.gl.COMPILE_STATUS)) {
				alert(_self.gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
	    }

	}

	setUniformLocation (){
		this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uPMatrix");
		this.shaderProgram.mMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uMMatrix");
		this.shaderProgram.vMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uVMatrix");
		this.shaderProgram.samplerUniform = this.gl.getUniformLocation(this.shaderProgram, "uSampler0");
		this.shaderProgram.uniformVertexTextureFactor = this.gl.getUniformLocation(this.shaderProgram, "uFactor0");
		this.gl.uniform1f(this.shaderProgram.uniformVertexTextureFactor, 1.0);
	}
	
	initBuffer() {
		
		
		console.log("[HiPS::initBuffer]");
		var nPixels = this.pixels.length;
		var vertexPosition = new Float32Array(12*nPixels);

		var facesVec3Array;
		var p = [];
		
		var theta0, theta1, theta2, theta3;
		var phi0, phi1, phi2, phi3;
		
		var epsilon = 0.0;
		for (var i=0; i < nPixels; i++){			
			
			facesVec3Array = new Array();
			facesVec3Array = this.healpix.getBoundaries(currentObj.pixels[i]);
			
			
			if (this.radius != 1){
				// HiPS radius different from Healpix default radius 1. 
				// Mapping HEALPix coordinates to the new sphere and radius
				theta0 = Math.acos(facesVec3Array[0].z);
				theta1 = Math.acos(facesVec3Array[1].z);
				theta2 = Math.acos(facesVec3Array[2].z);
				theta3 = Math.acos(facesVec3Array[3].z);
				
				phi0 = Math.atan2(facesVec3Array[0].y, facesVec3Array[0].x);
				phi1 = Math.atan2(facesVec3Array[1].y, facesVec3Array[1].x);
				phi2 = Math.atan2(facesVec3Array[2].y, facesVec3Array[2].x);
				phi3 = Math.atan2(facesVec3Array[3].y, facesVec3Array[3].x);
				
				vertexPosition[12*i] = -this.radius * Math.sin(theta0) * Math.cos(phi0);
				vertexPosition[12*i+1] = this.radius * Math.sin(theta0) * Math.sin(phi0);
				vertexPosition[12*i+2] = this.radius * Math.cos(theta0);
				
				vertexPosition[12*i+3] = -this.radius * Math.sin(theta1) * Math.cos(phi1);
				vertexPosition[12*i+4] = this.radius * Math.sin(theta1) * Math.sin(phi1);
				vertexPosition[12*i+5] = this.radius * Math.cos(theta1);
				
				vertexPosition[12*i+6] = -this.radius * Math.sin(theta2) * Math.cos(phi2);
				vertexPosition[12*i+7] = this.radius * Math.sin(theta2) * Math.sin(phi2);
				vertexPosition[12*i+8] = this.radius * Math.cos(theta2);
				
				vertexPosition[12*i+9] = -this.radius * Math.sin(theta3) * Math.cos(phi3);
				vertexPosition[12*i+10] = this.radius * Math.sin(theta3) * Math.sin(phi3);
				vertexPosition[12*i+11] = this.radius * Math.cos(theta3);
				
			}else{
				// Default Healpix radius 1
				vertexPosition[12*i] = facesVec3Array[0].x ;
				vertexPosition[12*i+1] = facesVec3Array[0].y ;
				vertexPosition[12*i+2] = facesVec3Array[0].z;
				
				vertexPosition[12*i+3] = facesVec3Array[1].x;
				vertexPosition[12*i+4] = facesVec3Array[1].y;
				vertexPosition[12*i+5] = facesVec3Array[1].z;
				
				vertexPosition[12*i+6] = facesVec3Array[2].x;
				vertexPosition[12*i+7] = facesVec3Array[2].y;
				vertexPosition[12*i+8] = facesVec3Array[2].z;
				
				vertexPosition[12*i+9] = facesVec3Array[3].x;
				vertexPosition[12*i+10] = facesVec3Array[3].y;
				vertexPosition[12*i+11] = facesVec3Array[3].z;
				
			}
		}
		
		var textureCoordinates = new Float32Array(8*nPixels);
	    if (this.fovObj.getMinFoV() >= this.allskyFovLimit){ // AllSky
	    	//0.037037037
	    	var s_step=1/27;
	    	//0.034482759
	    	var t_step=1/29;
	    	
	    	var sindex = 0;
	    	var tindex = 0;
	    	for (var i=0; i < nPixels; i++){
	    		// AllSky map. One map texture
	        	// [1, 0],[1, 1],[0, 1],[0, 0]
	        	textureCoordinates[8*i] = (s_step + (s_step * sindex)).toFixed(9);
	        	textureCoordinates[8*i+1] = (1 - (t_step + t_step * tindex)).toFixed(9);
	        	textureCoordinates[8*i+2] = (s_step + (s_step * sindex)).toFixed(9);
	        	textureCoordinates[8*i+3] = (1 - (t_step * tindex)).toFixed(9);
	        	textureCoordinates[8*i+4] = (s_step * sindex).toFixed(9);
	        	textureCoordinates[8*i+5] = (1 - (t_step * tindex)).toFixed(9);
	        	textureCoordinates[8*i+6] = (s_step * sindex).toFixed(9);
	        	textureCoordinates[8*i+7] = (1 - (t_step + t_step * tindex)).toFixed(9);
	        	sindex++;
	        	if(sindex == 27){
	        		tindex++;
	        		sindex=0;
	        	}
	        }
	    }else{
	    	for (var i=0; i < nPixels; i++){
	        	// UV mapping: 1, 0],[1, 1],[0, 1],[0, 0]
	    		textureCoordinates[8*i] = 1.0;
	        	textureCoordinates[8*i+1] = 0.0;
	        	textureCoordinates[8*i+2] = 1.0;
	        	textureCoordinates[8*i+3] = 1.0;
	        	textureCoordinates[8*i+4] = 0.0;
	        	textureCoordinates[8*i+5] = 1.0;
	        	textureCoordinates[8*i+6] = 0.0;
	        	textureCoordinates[8*i+7] = 0.0;

	        }
	    }		
		
	    
	    
	    var vertexIndices = new Uint16Array(6*nPixels);
	    var baseFaceIndex = 0; 
	    for (var j=0; j< nPixels; j++){

	    	vertexIndices[6*j] = baseFaceIndex;
	    	vertexIndices[6*j+1] = baseFaceIndex + 1;
	    	vertexIndices[6*j+2] = baseFaceIndex + 2;
	    	
	    	vertexIndices[6*j+3] = baseFaceIndex;
	    	vertexIndices[6*j+4] = baseFaceIndex + 2;
	    	vertexIndices[6*j+5] = baseFaceIndex + 3;
	    		
	    	baseFaceIndex = baseFaceIndex+4;
	    	
	    }
	    
	    this.vertexPositionBuffer = this.gl.createBuffer();
	    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, currentObj.vertexPositionBuffer);
	    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexPosition, this.gl.STATIC_DRAW);
		this.vertexPositionBuffer.itemSize = 3;
	    this.vertexPositionBuffer.numItems = vertexPosition.length;
		
		this.vertexTextureCoordBuffer = this.gl.createBuffer();
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer); 
		this.gl.bufferData(this.gl.ARRAY_BUFFER, textureCoordinates, this.gl.STATIC_DRAW);
		this.vertexTextureCoordBuffer.itemSize = 2;
		this.vertexTextureCoordBuffer.numItems = textureCoordinates.length;
	    
		
	    this.vertexIndexBuffer = this.gl.createBuffer();
	    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
	    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, vertexIndices, this.gl.STATIC_DRAW);
	    this.vertexIndexBuffer.itemSize = 1;
	    this.vertexIndexBuffer.numItems = vertexIndices.length;
	    
	};

	refreshModel (in_fov, in_pan){
		if ( in_fov >= 179){
			this.order = 0;
		}else if ( in_fov >= 62){
			this.order = 1;
		}else if ( in_fov >= 25){
			this.order = 2;
		}else if ( in_fov >= 12.5){
			this.order = 3;
		}else if (in_fov >= 6){
			this.order = 4;
		}else if (in_fov >= 3.2){
			this.order = 5;
		}else if (in_fov >= 1.6){
			this.order = 6;
		}else if (in_fov >= 0.85){
			this.order = 7;
		}else if (in_fov >= 0.42){
			this.order = 8;
		}else if (in_fov >= 0.21){
			this.order = 9;
		}else if (in_fov >= 0.12){
			this.order = 10;
		}else if (in_fov >= 0.08){
			this.order = 11;
		}else{
			this.order = 12;
		}
		this.order = Math.min(this.order, this.maxOrder);
		
		if ( global.order != this.order && DEBUG){
			console.log("Changed order = "+ this.order);
		}
		global.order = this.order;

		this.changedModel = true;
	}

	updateVisibleTiles (){
		if(!this.changedModel){return;}
		this.changedModel = false;
		let previouslyVisibleKeys = Object.keys(this.visibleTiles);
		if(this.order == 0){
			this.removeTiles(this.visibleTiles);
			return;
		}
		let tilesRemoved = this.visibleTiles;
		let tilesAdded = {};
		this.visibleTiles = {};
		let tilesToAddInOrder = this.pollCenter(previouslyVisibleKeys, tilesRemoved, tilesAdded);

		this.pollViewAndAddTiles(7, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder);
		
		Object.keys(this.visibleTiles).forEach(key =>{
			this.addNeighbours(this.visibleTiles[key].ipix, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder);
		});

		this.removeTiles(tilesRemoved);
		tilesToAddInOrder.forEach(tile => {
			tile.addToView();
		});
	}

	removeTiles(tilesRemoved){
		Object.keys(tilesRemoved).forEach(key => {
			tilesRemoved[key].removeFromView();
		});
	}

	pollViewAndAddTiles(xyPollingPoints, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder) {
		let maxX = this.gl.canvas.width;
		let maxY = this.gl.canvas.height;

		for (let i = 0; i <= maxX; i += maxX / xyPollingPoints) {
			for (let j = 0; j <= maxY; j += maxY / xyPollingPoints) {
				this.pollPoint(i, j, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder);
			}
		}
	}

	pollCenter(previouslyVisibleKeys, tilesRemoved, tilesAdded) {
		let tilesToAddInOrder = [];
		let maxX = this.gl.canvas.width;
		let maxY = this.gl.canvas.height;
		let xyPollingPoints = 3;
		this.pollPoint(maxX / 2, maxY / 2, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder);
		for (let i = maxX / xyPollingPoints; i <= maxX * 2 / xyPollingPoints; i += maxX / xyPollingPoints) {
			for (let j = maxY / xyPollingPoints; j <= maxY * 2 / xyPollingPoints; j += maxY / xyPollingPoints) {
				this.pollPoint(i, j, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder);
			}
		}
		return tilesToAddInOrder;
	}

	pollPoint(x, y, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder) {
		let intersectionWithModel = RayPickingUtils.getIntersectionPointWithSingleModel(x, y, this);
		let intersectionPoint = intersectionWithModel.intersectionPoint;
		// TODO probably it would be better to use query_disc_inclusive from HEALPix
		// against a polygon. Check my FHIPSWebGL2 project (BufferManager.js -> updateVisiblePixels)
		if (intersectionPoint.length > 0) {
			let currP = new Pointing(new Vec3(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2]));
			let currPixNo = global.getHealpix(this.order).ang2pix(currP);
			if (currPixNo >= 0) {
				let tile = tileBufferSingleton.getTile(this.order, currPixNo, this.format, this.URL);
				this.visibleTiles[tile.key] = tile;
				if (previouslyVisibleKeys.includes(tile.key)) {
					delete tilesRemoved[tile.key];
				} else {
					if (tilesAdded[tile.key] !== tile) {
						tilesToAddInOrder.push(tile);
					}
					tilesAdded[tile.key] = tile;
				}
			}
		}
	}

	addNeighbours(currPixNo, previouslyVisibleKeys, tilesRemoved, tilesAdded, tilesToAddInOrder) {
		let neighbours = global.getHealpix(this.order).neighbours(currPixNo);
		for (let k = 0; k < neighbours.length; k++) {
			if (neighbours[k] >= 0 && this.visibleTiles[neighbours[k]] == undefined) {
				let tile = tileBufferSingleton.getTile(this.order, neighbours[k], this.format, this.URL);
				this.visibleTiles[tile.key] = tile;

				if (previouslyVisibleKeys.includes(tile.key)) {
					delete tilesRemoved[tile.key];
				} else {
					if(tilesAdded[tile.key] !== tile){
						tilesToAddInOrder.push(tile);
					}
					tilesAdded[tile.key] = tile;
				}
			}
		}
		return neighbours;
	}

	enableShader(pMatrix, vMatrix){
		this.gl.useProgram(this.shaderProgram);

		this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uPMatrix");
		this.shaderProgram.mMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uMMatrix");
		this.shaderProgram.vMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uVMatrix");
		this.shaderProgram.samplerUniform = this.gl.getUniformLocation(this.shaderProgram, "uSampler0");
		this.shaderProgram.uniformVertexTextureFactor = this.gl.getUniformLocation(this.shaderProgram, "uFactor0");
		this.shaderProgram.sphericalGridEnabledUniform = this.gl.getUniformLocation(this.shaderProgram, "uSphericalGrid");

		this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
		this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");

		this.gl.uniform1f(this.shaderProgram.uniformVertexTextureFactor, 1.0);
		this.gl.uniformMatrix4fv(this.shaderProgram.mMatrixUniform, false, this.modelMatrix);
		this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, pMatrix);
		this.gl.uniformMatrix4fv(this.shaderProgram.vMatrixUniform, false, vMatrix);

		this.uniformVertexTextureFactorLoc = this.gl.getUniformLocation(this.shaderProgram, "uFactor0");

		this.gl.uniform1f(this.shaderProgram.sphericalGridEnabledUniform, 0.0);
	}


	draw(pMatrix, vMatrix){
//		// TODO enable BLENDING to be checked since for some HiPS (like Herschel) alpha is set to 0 when no data   
//		this.gl.enable(this.gl.BLEND);
//		tileDrawerSingleton.draw(pMatrix, vMatrix, this.modelMatrix);
//		this.gl.disable(this.gl.BLEND);
//		
//		healpixGridTileDrawerSingleton.draw(pMatrix, vMatrix, this.modelMatrix);
		
		this.enableShader(pMatrix, vMatrix);
		
		
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexPositionBuffer);
		this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.vertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
		
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, currentObj.vertexTextureCoordBuffer);
		this.gl.vertexAttribPointer(this.shaderProgram.textureCoordAttribute, this.vertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
		
		this.gl.bindBuffer(in_gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
		
		this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
		this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
		
		
		if (this.getMinFoV() >= this.allskyFovLimit){ // AllSky
			this.gl.activeTexture(this.gl.TEXTURE0);
			this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.images[0]);
			this.gl.uniform1f(this.shaderProgram.uniformVertexTextureFactor, this.opacity);
			
			
		    for (var i=0;i<this.pixels.length;i++){
		    	this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 12*i);
	        }
		    
		}else{
			
			for (var i=0;i<currentObj.pixels.length;i++){
					
				this.gl.activeTexture(this.gl.TEXTURE0);
				this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.images[i]);
				this.gl.uniform1f(this.uniformVertexTextureFactorLoc, this.opacity);
					
				this.gl.drawElements(in_gl.TRIANGLES, 6, 
						this.gl.UNSIGNED_SHORT, 12*i);
			}
			
			
		}
		
		
		
		if (this.showSphericalGrid) {
			this.sphericalGrid.draw(this.shaderProgram);
	    }
	    if (this.showEquatorialGrid) {
	    	this.drawEquatorialGrid();
	    }

	    if (this.showXyzRefCoord){
	    	this.xyzRefSystem.draw(this.shaderProgram);
		}
	}


	drawSphericalGrid (){

		var x, y, z;
		var r = 1.004;
		var thetaRad, phiRad;

		var thetaStep, phiStep;

		this.gl.uniform1f(this.shaderProgram.sphericalGridEnabledUniform, 1.0);

		thetaStep = 10;
		phiStep = 10;

		for (var theta = 0; theta < 180; theta += thetaStep){

			var phiVertexPosition = new Float32Array(360/phiStep * 3);

			thetaRad = degToRad(theta);

			for (var phi = 0; phi <360; phi += phiStep){

				phiRad = degToRad(phi);

				x = r * Math.sin(thetaRad) * Math.cos(phiRad);
				y = r * Math.sin(thetaRad) * Math.sin(phiRad);
				z = r * Math.cos(thetaRad);

				phiVertexPosition[ 3 * (phi/phiStep)] = x;
				phiVertexPosition[ 3 * (phi/phiStep) + 1] = y;
				phiVertexPosition[ 3 * (phi/phiStep) + 2] = z;

			}

			var phiVertexPositionBuffer = this.gl.createBuffer();
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, phiVertexPositionBuffer);
			this.gl.bufferData(this.gl.ARRAY_BUFFER, phiVertexPosition, this.gl.STATIC_DRAW);

			this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);

			this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

			this.gl.drawArrays(this.gl.LINE_LOOP, 0, 360/phiStep);
		}


		thetaStep = 10;
		phiStep = 10;

		for (var phi = 0; phi <360; phi += phiStep){

			var thetaVertexPosition = new Float32Array(360/thetaStep * 3);

			phiRad = degToRad(phi);


			for (var theta = 0; theta <360; theta += thetaStep){

				thetaRad = degToRad(theta);

				x = r * Math.sin(thetaRad) * Math.cos(phiRad);
				y = r * Math.sin(thetaRad) * Math.sin(phiRad);
				z = r * Math.cos(thetaRad);


				thetaVertexPosition[ 3 * (theta/thetaStep)] = x;
				thetaVertexPosition[ 3 * (theta/thetaStep) + 1] = y;
				thetaVertexPosition[ 3 * (theta/thetaStep) + 2] = z;

			}

			var thetaVertexPositionBuffer = this.gl.createBuffer();
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, thetaVertexPositionBuffer);
			this.gl.bufferData(this.gl.ARRAY_BUFFER, thetaVertexPosition, this.gl.STATIC_DRAW);

			this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);

			this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

			this.gl.drawArrays(this.gl.LINE_LOOP, 0, 360/thetaStep);

		}


			var versors = [
				[1.5, 0.0, 0.0],
				[0.0, 1.5, 0.0],
				[0.0, 0.0, 1.5],
				];

			var refSysPosition = new Float32Array(3 * 2);

			refSysPosition[0] = 0.0;
			refSysPosition[1] = 0.0;
			refSysPosition[2] = 0.0;

			/*
			 * x red
			 * y green
			 * z blue
			 */
			for (var k=0; k<3; k++){

				this.gl.uniform1f(this.shaderProgram.sphericalGridEnabledUniform, k + 2.0);

				refSysPosition[3] = versors[k][0];
				refSysPosition[4] = versors[k][1];
				refSysPosition[5] = versors[k][2];

				var refSysPositionBuffer = this.gl.createBuffer();
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, refSysPositionBuffer);
				this.gl.bufferData(this.gl.ARRAY_BUFFER, refSysPosition, this.gl.STATIC_DRAW);

				this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);

				this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

				this.gl.drawArrays(this.gl.LINE_STRIP, 0, 2);

			}

	}

	drawEquatorialGrid (){

	}

}

export default HiPS;
